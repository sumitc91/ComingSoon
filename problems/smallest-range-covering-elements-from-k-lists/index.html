<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smallest Range Covering Elements from K Lists - LeetCodee Solution</title>
    <meta name="description" content="Find the smallest range that includes at least one number from each of the k lists of sorted integers.  LeetCodee solution with Python, Java, C++, JavaScript, and C# code examples.">
    <meta name="keywords" content="leetcode, smallest range, k lists, sorted integers, algorithm, solution, python, java, cpp, javascript, csharp, coding, interview">
    <link rel="canonical" href="https://leetcodee.com/problems/smallest-range-covering-elements-from-k-lists/">
    <meta property="og:title" content="Smallest Range Covering Elements from K Lists - LeetCodee Solution">
    <meta property="og:description" content="Find the smallest range that includes at least one number from each of the k lists of sorted integers.  LeetCodee solution with Python, Java, C++, JavaScript, and C# code examples.">
    <meta property="og:url" content="https://leetcodee.com/problems/smallest-range-covering-elements-from-k-lists/">
    <meta property="og:type" content="article">
    <meta property="og:site_name" content="LeetCodee">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-F7SQYSXXMM"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-F7SQYSXXMM');
    </script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1068871795581451"
     crossorigin="anonymous"></script>
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Article",
      "headline": "Smallest Range Covering Elements from K Lists",
      "author": {
        "@type": "Organization",
        "name": "LeetCodee"
      },
      "datePublished": "2023-10-27",
      "dateModified": "2023-10-27",
      "description": "Find the smallest range that includes at least one number from each of the k lists of sorted integers. LeetCodee solution with Python, Java, C++, JavaScript, and C# code examples.",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://leetcodee.com/problems/smallest-range-covering-elements-from-k-lists/"
      },
      "keywords": "leetcode, smallest range, k lists, sorted integers, algorithm, solution, python, java, cpp, javascript, csharp, coding, interview"
    }
    </script>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body class="bg-gray-100">
    <header class="bg-gray-800 text-white p-4">
        <div class="container mx-auto">
            <a href="/" class="text-xl font-bold">LeetCodee</a>
        </div>
    </header>

    <main class="container mx-auto p-4">
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h1 class="text-3xl font-bold mb-4">632. Smallest Range Covering Elements from K Lists</h1>

            <div class="solution-nav mb-6">
                Jump to Solution:
                <a href="#python" class="ml-2 text-blue-600 hover:text-blue-800">Python</a>
                <a href="#java" class="ml-2 text-blue-600 hover:text-blue-800">Java</a>
                <a href="#cpp" class="ml-2 text-blue-600 hover:text-blue-800">C++</a>
                <a href="#javascript" class="ml-2 text-blue-600 hover:text-blue-800">JavaScript</a>
                <a href="#csharp" class="ml-2 text-blue-600 hover:text-blue-800">C#</a>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Problem Description</h2>
                <p class="text-gray-700 mb-4">
                    You have <code class="bg-gray-100 px-1 rounded">k</code> lists of sorted integers in non-decreasing order. Find the <strong>smallest</strong> range that includes at least one number from each of the <code class="bg-gray-100 px-1 rounded">k</code> lists.
                </p>
                <p class="text-gray-700 mb-4">
                    We define the range <code class="bg-gray-100 px-1 rounded">[a, b]</code> is smaller than range <code class="bg-gray-100 px-1 rounded">[c, d]</code> if <code class="bg-gray-100 px-1 rounded">b - a < d - c</code> or <code class="bg-gray-100 px-1 rounded">a < c</code> if <code class="bg-gray-100 px-1 rounded">b - a == d - c</code>.
                </p>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Examples:</h2>
                <div class="mb-4">
                    <p class="font-semibold">Example 1:</p>
                    <pre class="bg-gray-100 p-4 rounded">
Input: nums = [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]
Output: [20,24]
Explanation: 
List 1: [4,10,15,24,26], 24 is in range [20,24]
List 2: [0,9,12,20], 20 is in range [20,24]
List 3: [5,18,22,30], 22 is in range [20,24]</pre>
                </div>
                <div class="mb-4">
                    <p class="font-semibold">Example 2:</p>
                    <pre class="bg-gray-100 p-4 rounded">
Input: nums = [[1,2,3],[1,2,3],[1,2,3]]
Output: [1,1]</pre>
                </div>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Constraints:</h2>
                <ul class="list-disc list-inside text-gray-700">
                    <li>nums.length == k</li>
                    <li>1 ≤ k ≤ 3500</li>
                    <li>1 ≤ nums[i].length ≤ 50</li>
                    <li>-10<sup>5</sup> ≤ nums[i][j] ≤ 10<sup>5</sup></li>
                    <li>nums[i] is sorted in non-decreasing order</li>
                </ul>
            </div>

            <!-- Python Solution -->
            <div id="python" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">Python Solution</h3>
                <pre class="language-python"><code>class Solution:
    def smallestRange(self, nums: List[List[int]]) -> List[int]:
        heap = []
        max_val = float('-inf')
        
        # Initialize heap with first element from each list
        for i, num_list in enumerate(nums):
            if num_list:
                heapq.heappush(heap, (num_list[0], i, 0))
                max_val = max(max_val, num_list[0])
        
        result = [float('-inf'), float('inf')]
        
        # Process until any list is exhausted
        while len(heap) == len(nums):
            min_val, list_index, num_index = heapq.heappop(heap)
            
            # Update result if current range is smaller
            if max_val - min_val < result[1] - result[0]:
                result = [min_val, max_val]
            
            # Move to next element in the current list
            if num_index + 1 < len(nums[list_index]):
                next_val = nums[list_index][num_index + 1]
                heapq.heappush(heap, (next_val, list_index, num_index + 1))
                max_val = max(max_val, next_val)
        
        return result</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Alternative Solution (Using Merge):</h4>
                    <pre class="language-python"><code>class Solution:
    def smallestRange(self, nums: List[List[int]]) -> List[int]:
        # Create merged list with original list indices
        merged = []
        for i, num_list in enumerate(nums):
            for num in num_list:
                merged.append((num, i))
        merged.sort()
        
        # Track count of numbers from each list
        count = defaultdict(int)
        required = len(nums)
        current = 0
        left = 0
        result = [float('-inf'), float('inf')]
        
        # Sliding window approach
        for right, (num, list_index) in enumerate(merged):
            count[list_index] += 1
            if count[list_index] == 1:
                current += 1
            
            # Try to minimize window while maintaining coverage
            while current == required:
                if merged[right][0] - merged[left][0] < result[1] - result[0]:
                    result = [merged[left][0], merged[right][0]]
                
                left_list_index = merged[left][1]
                count[left_list_index] -= 1
                if count[left_list_index] == 0:
                    current -= 1
                left += 1
        
        return result</code></pre>
                
                <h4 class="text-lg font-semibold mb-2 mt-4">Implementation Notes:</h4>
                <ul class="list-disc list-inside text-gray-700 space-y-2">
                    <li>First solution uses min heap: O(n * log k) time, O(k) space</li>
                    <li>Second solution uses merge and sliding window: O(n * log n) time, O(n) space</li>
                    <li>Both handle edge cases and maintain optimal range</li>
                    <li>Heap solution is generally more efficient for large k</li>
                </ul>
            </div>

            <!-- Java Solution -->
            <div id="java" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">Java Solution</h3>
                <pre class="language-java"><code>class Solution {
    public int[] smallestRange(List<List<Integer>> nums) {
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        int max = Integer.MIN_VALUE;
        
        // Initialize heap with first element from each list
        for (int i = 0; i < nums.size(); i++) {
            if (!nums.get(i).isEmpty()) {
                pq.offer(new int[]{nums.get(i).get(0), i, 0});
                max = Math.max(max, nums.get(i).get(0));
            }
        }
        
        int[] result = new int[]{Integer.MIN_VALUE, Integer.MAX_VALUE};
        
        while (pq.size() == nums.size()) {
            int[] curr = pq.poll();
            int min = curr[0], listIndex = curr[1], numIndex = curr[2];
            
            if (max - min < result[1] - result[0] || 
                (max - min == result[1] - result[0] && min < result[0])) {
                result[0] = min;
                result[1] = max;
            }
            
            if (numIndex + 1 < nums.get(listIndex).size()) {
                int nextVal = nums.get(listIndex).get(numIndex + 1);
                pq.offer(new int[]{nextVal, listIndex, numIndex + 1});
                max = Math.max(max, nextVal);
            }
        }
        
        return result;
    }
}</code></pre>
            </div>

            <!-- C++ Solution -->
            <div id="cpp" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">C++ Solution</h3>
                <pre class="language-cpp"><code>class Solution {
public:
    vector<int> smallestRange(vector<vector<int>>& nums) {
        priority_queue<pair<int, pair<int, int>>, 
                      vector<pair<int, pair<int, int>>>, 
                      greater<>> pq;
        int max_val = INT_MIN;
        
        // Initialize heap with first element from each list
        for (int i = 0; i < nums.size(); i++) {
            if (!nums[i].empty()) {
                pq.push({nums[i][0], {i, 0}});
                max_val = max(max_val, nums[i][0]);
            }
        }
        
        vector<int> result = {INT_MIN, INT_MAX};
        
        while (pq.size() == nums.size()) {
            auto [min_val, indices] = pq.top();
            auto [list_index, num_index] = indices;
            pq.pop();
            
            if (max_val - min_val < result[1] - result[0] || 
                (max_val - min_val == result[1] - result[0] && min_val < result[0])) {
                result = {min_val, max_val};
            }
            
            if (num_index + 1 < nums[list_index].size()) {
                int next_val = nums[list_index][num_index + 1];
                pq.push({next_val, {list_index, num_index + 1}});
                max_val = max(max_val, next_val);
            }
        }
        
        return result;
    }
};</code></pre>
            </div>

            <!-- JavaScript Solution -->
            <div id="javascript" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">JavaScript Solution</h3>
                <pre class="language-javascript"><code>/**
 * @param {number[][]} nums
 * @return {number[]}
 */
var smallestRange = function(nums) {
    const heap = new MinHeap();
    let maxVal = -Infinity;
    
    // Initialize heap with first element from each list
    for (let i = 0; i < nums.length; i++) {
        if (nums[i].length > 0) {
            heap.push([nums[i][0], i, 0]);
            maxVal = Math.max(maxVal, nums[i][0]);
        }
    }
    
    const result = [-Infinity, Infinity];
    
    while (heap.size() === nums.length) {
        const [minVal, listIndex, numIndex] = heap.pop();
        
        if (maxVal - minVal < result[1] - result[0] ||
            (maxVal - minVal === result[1] - result[0] && minVal < result[0])) {
            result[0] = minVal;
            result[1] = maxVal;
        }
        
        if (numIndex + 1 < nums[listIndex].length) {
            const nextVal = nums[listIndex][numIndex + 1];
            heap.push([nextVal, listIndex, numIndex + 1]);
            maxVal = Math.max(maxVal, nextVal);
        }
    }
    
    return result;
};

class MinHeap {
    constructor() {
        this.heap = [];
    }
    
    push(val) {
        this.heap.push(val);
        this.bubbleUp(this.heap.length - 1);
    }
    
    pop() {
        if (this.heap.length === 0) return null;
        if (this.heap.length === 1) return this.heap.pop();
        
        const result = this.heap[0];
        this.heap[0] = this.heap.pop();
        this.bubbleDown(0);
        return result;
    }
    
    bubbleUp(index) {
        while (index > 0) {
            const parent = Math.floor((index - 1) / 2);
            if (this.heap[parent][0] <= this.heap[index][0]) break;
            
            [this.heap[parent], this.heap[index]] = 
                [this.heap[index], this.heap[parent]];
            index = parent;
        }
    }
    
    bubbleDown(index) {
        while (true) {
            let smallest = index;
            const left = 2 * index + 1;
            const right = 2 * index + 2;
            
            if (left < this.heap.length && 
                this.heap[left][0] < this.heap[smallest][0]) {
                smallest = left;
            }
            if (right < this.heap.length && 
                this.heap[right][0] < this.heap[smallest][0]) {
                smallest = right;
            }
            
            if (smallest === index) break;
            
            [this.heap[index], this.heap[smallest]] = 
                [this.heap[smallest], this.heap[index]];
            index = smallest;
        }
    }
    
    size() {
        return this.heap.length;
    }
}</code></pre>
            </div>

            <!-- C# Solution -->
            <div id="csharp" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">C# Solution</h3>
                <pre class="language-csharp"><code>public class Solution {
    public int[] SmallestRange(IList<IList<int>> nums) {
        var pq = new PriorityQueue<(int val, int listIndex, int numIndex), int>();
        int maxVal = int.MinValue;
        
        // Initialize heap with first element from each list
        for (int i = 0; i < nums.Count; i++) {
            if (nums[i].Count > 0) {
                pq.Enqueue((nums[i][0], i, 0), nums[i][0]);
                maxVal = Math.Max(maxVal, nums[i][0]);
            }
        }
        
        var result = new int[] { int.MinValue, int.MaxValue };
        
        while (pq.Count == nums.Count) {
            var (minVal, listIndex, numIndex) = pq.Dequeue();
            
            if (maxVal - minVal < result[1] - result[0] ||
                (maxVal - minVal == result[1] - result[0] && minVal < result[0])) {
                result[0] = minVal;
                result[1] = maxVal;
            }
            
            if (numIndex + 1 < nums[listIndex].Count) {
                int nextVal = nums[listIndex][numIndex + 1];
                pq.Enqueue((nextVal, listIndex, numIndex + 1), nextVal);
                maxVal = Math.Max(maxVal, nextVal);
            }
        }
        
        return result;
    }
}</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Alternative Solution using LINQ:</h4>
                    <pre class="language-csharp"><code>public class Solution {
    public int[] SmallestRange(IList<IList<int>> nums) {
        var merged = nums.SelectMany((list, i) => 
            list.Select(num => (num, listIndex: i)))
            .OrderBy(x => x.num)
            .ToList();
        
        var count = new Dictionary<int, int>();
        int required = nums.Count;
        int current = 0;
        int left = 0;
        var result = new int[] { int.MinValue, int.MaxValue };
        
        for (int right = 0; right < merged.Count; right++) {
            var (num, listIndex) = merged[right];
            count[listIndex] = count.GetValueOrDefault(listIndex) + 1;
            if (count[listIndex] == 1) current++;
            
            while (current == required) {
                if (merged[right].num - merged[left].num < result[1] - result[0]) {
                    result[0] = merged[left].num;
                    result[1] = merged[right].num;
                }
                
                var leftListIndex = merged[left].listIndex;
                count[leftListIndex]--;
                if (count[leftListIndex] == 0) current--;
                left++;
            }
        }
        
        return result;
    }
}</code></pre>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Implementation Notes:</h4>
                    <ul class="list-disc list-inside text-gray-700 space-y-2">
                        <li>First solution uses PriorityQueue for efficient min value tracking</li>
                        <li>LINQ solution provides a more functional approach</li>
                        <li>Both solutions handle all edge cases</li>
                        <li>PriorityQueue solution is generally more efficient</li>
                    </ul>
                </div>
            </div>
        </div>
    </main>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-csharp.min.js"></script>
</body>
</html>