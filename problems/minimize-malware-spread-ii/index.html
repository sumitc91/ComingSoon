<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimize Malware Spread II - LeetCodee Solution</title>
    <meta name="description" content="Find the node to remove to minimize malware spread.  LeetCodee solution with Python, Java, C++, JavaScript, and C# code examples.">
    <meta name="keywords" content="leetcode, minimize malware spread ii, graph, algorithm, solution, python, java, c++, javascript, c#, union-find, adjacency matrix">
    <link rel="canonical" href="https://leetcodee.com/problems/minimize-malware-spread-ii/">
    <meta property="og:title" content="Minimize Malware Spread II - LeetCodee Solution">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://leetcodee.com/problems/minimize-malware-spread-ii/">
    <meta property="og:description" content="Find the node to remove to minimize malware spread. LeetCodee solution with Python, Java, C++, JavaScript, and C# code examples.">
    <meta property="og:image" content="https://leetcodee.com/logo.png">  <!-- Replace with your actual logo URL -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-F7SQYSXXMM"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-F7SQYSXXMM');
    </script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1068871795581451"
     crossorigin="anonymous"></script>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Article",
      "headline": "Minimize Malware Spread II - LeetCodee Solution",
      "author": {
        "@type": "Person",
        "name": "LeetCodee"
      },
      "datePublished": "2023-10-27",  <!-- Replace with actual publication date -->
      "dateModified": "2023-10-27",  <!-- Replace with actual modification date -->
      "description": "Find the node to remove to minimize malware spread. LeetCodee solution with Python, Java, C++, JavaScript, and C# code examples.",
      "image": "https://leetcodee.com/logo.png",  <!-- Replace with your actual logo URL -->
      "articleBody": "You are given a network of n nodes represented as an n x n adjacency matrix graph, where the ith node is directly connected to the jth node if graph[i][j] == 1.  [ ... rest of the problem description ... ]",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://leetcodee.com/problems/minimize-malware-spread-ii/"
      }
    }
    </script>
</head>
<body class="bg-gray-100">
    <header class="bg-gray-800 text-white p-4">
        <div class="container mx-auto">
            <a href="/" class="text-xl font-bold">LeetCodee</a>
        </div>
    </header>

    <main class="container mx-auto p-4">
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h1 class="text-3xl font-bold mb-4">928. Minimize Malware Spread II</h1>

            <div class="solution-nav mb-6">
                Jump to Solution:
                <a href="#python" class="ml-2 text-blue-600 hover:text-blue-800">Python</a>
                <a href="#java" class="ml-2 text-blue-600 hover:text-blue-800">Java</a>
                <a href="#cpp" class="ml-2 text-blue-600 hover:text-blue-800">C++</a>
                <a href="#javascript" class="ml-2 text-blue-600 hover:text-blue-800">JavaScript</a>
                <a href="#csharp" class="ml-2 text-blue-600 hover:text-blue-800">C#</a>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Problem Description</h2>
                <p class="text-gray-700 mb-4">
                    You are given a network of <code class="bg-gray-100 px-1 rounded">n</code> nodes represented as an <code class="bg-gray-100 px-1 rounded">n x n</code> adjacency matrix <code class="bg-gray-100 px-1 rounded">graph</code>, where the <code class="bg-gray-100 px-1 rounded">i</code>th node is directly connected to the <code class="bg-gray-100 px-1 rounded">j</code>th node if <code class="bg-gray-100 px-1 rounded">graph[i][j] == 1</code>.
                </p>
                <p class="text-gray-700 mb-4">
                    Some nodes <code class="bg-gray-100 px-1 rounded">initial</code> are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.
                </p>
                <p class="text-gray-700 mb-4">
                    Suppose <code class="bg-gray-100 px-1 rounded">M(initial)</code> is the final number of nodes infected with malware in the entire network after the spread of malware stops. We will remove exactly one node from the <code class="bg-gray-100 px-1 rounded">initial</code> list.
                </p>
                <p class="text-gray-700 mb-4">
                    Return the node that, if removed, would minimize <code class="bg-gray-100 px-1 rounded">M(initial)</code>. If multiple nodes could be removed to minimize <code class="bg-gray-100 px-1 rounded">M(initial)</code>, return such a node with the smallest index.
                </p>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Example 1:</h2>
                <pre class="bg-gray-100 p-4 rounded"><code>Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
Output: 0</code></pre>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Example 2:</h2>
                <pre class="bg-gray-100 p-4 rounded"><code>Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
Output: 0</code></pre>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Example 3:</h2>
                <pre class="bg-gray-100 p-4 rounded"><code>Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
Output: 1</code></pre>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Constraints:</h2>
                <ul class="list-disc list-inside text-gray-700">
                    <li><code class="bg-gray-100 px-1 rounded">n == graph.length</code></li>
                    <li><code class="bg-gray-100 px-1 rounded">n == graph[i].length</code></li>
                    <li><code class="bg-gray-100 px-1 rounded">2 <= n <= 300</code></li>
                    <li><code class="bg-gray-100 px-1 rounded">graph[i][j]</code> is <code class="bg-gray-100 px-1 rounded">0</code> or <code class="bg-gray-100 px-1 rounded">1</code>.</li>
                    <li><code class="bg-gray-100 px-1 rounded">graph[i][i] == 1</code></li>
                    <li><code class="bg-gray-100 px-1 rounded">1 <= initial.length <= n</code></li>
                    <li><code class="bg-gray-100 px-1 rounded">0 <= initial[i] <= n - 1</code></li>
                    <li>All the integers in <code class="bg-gray-100 px-1 rounded">initial</code> are unique.</li>
                </ul>
            </div>
        </div>

        <!-- Solution Section -->
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h2 class="text-2xl font-bold mb-4">Solution</h2>
            
            <!-- Python Solution -->
            <div id="python" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">Python Solution</h3>
                <pre class="language-python"><code>class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]
            
        def union(x, y):
            px, py = find(x), find(y)
            if px != py:
                if size[px] < size[py]:
                    px, py = py, px
                parent[py] = px
                size[px] += size[py]
                
        n = len(graph)
        parent = list(range(n))
        size = [1] * n
        
        # Build the graph
        for i in range(n):
            for j in range(i + 1, n):
                if graph[i][j]:
                    union(i, j)
                    
        # Count infected nodes in each component
        infected = [0] * n
        for node in initial:
            infected[find(node)] += 1
            
        # Find the best node to remove
        best_node = min(initial)
        best_size = 0
        
        for node in initial:
            root = find(node)
            if infected[root] == 1 and size[root] > best_size:
                best_size = size[root]
                best_node = node
                
        return best_node</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(n^2)</h4>
                    <p class="text-gray-700">We need to process the adjacency matrix and perform union-find operations.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(n)</h4>
                    <p class="text-gray-700">We use arrays to store parent and size information for union-find.</p>
                </div>
            </div>

            <!-- Java Solution -->
            <div id="java" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">Java Solution</h3>
                <pre class="language-java"><code>class Solution {
    private int[] parent;
    private int[] size;
    
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        parent = new int[n];
        size = new int[n];
        
        // Initialize parent and size arrays
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
        
        // Build the graph
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (graph[i][j] == 1) {
                    union(i, j);
                }
            }
        }
        
        // Count infected nodes in each component
        int[] infected = new int[n];
        for (int node : initial) {
            infected[find(node)]++;
        }
        
        // Find the best node to remove
        int bestNode = initial[0];
        int bestSize = 0;
        
        for (int node : initial) {
            int root = find(node);
            if (infected[root] == 1 && size[root] > bestSize) {
                bestSize = size[root];
                bestNode = node;
            }
        }
        
        return bestNode;
    }
    
    private int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    
    private void union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px != py) {
            if (size[px] < size[py]) {
                int temp = px;
                px = py;
                py = temp;
            }
            parent[py] = px;
            size[px] += size[py];
        }
    }
}</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(n^2)</h4>
                    <p class="text-gray-700">We need to process the adjacency matrix and perform union-find operations.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(n)</h4>
                    <p class="text-gray-700">We use arrays to store parent and size information for union-find.</p>
                </div>
            </div>

            <!-- C++ Solution -->
            <div id="cpp" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">C++ Solution</h3>
                <pre class="language-cpp"><code>class Solution {
private:
    vector<int> parent;
    vector<int> size;
    
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    
    void union_set(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px != py) {
            if (size[px] < size[py]) {
                swap(px, py);
            }
            parent[py] = px;
            size[px] += size[py];
        }
    }
    
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        parent.resize(n);
        size.resize(n, 1);
        
        // Initialize parent array
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
        
        // Build the graph
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (graph[i][j]) {
                    union_set(i, j);
                }
            }
        }
        
        // Count infected nodes in each component
        vector<int> infected(n, 0);
        for (int node : initial) {
            infected[find(node)]++;
        }
        
        // Find the best node to remove
        int bestNode = initial[0];
        int bestSize = 0;
        
        for (int node : initial) {
            int root = find(node);
            if (infected[root] == 1 && size[root] > bestSize) {
                bestSize = size[root];
                bestNode = node;
            }
        }
        
        return bestNode;
    }
};</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(n^2)</h4>
                    <p class="text-gray-700">We need to process the adjacency matrix and perform union-find operations.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(n)</h4>
                    <p class="text-gray-700">We use arrays to store parent and size information for union-find.</p>
                </div>
            </div>

            <!-- JavaScript Solution -->
            <div id="javascript" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">JavaScript Solution</h3>
                <pre class="language-javascript"><code>/**
 * @param {number[][]} graph
 * @param {number[]} initial
 * @return {number}
 */
var minMalwareSpread = function(graph, initial) {
    const n = graph.length;
    const parent = new Array(n);
    const size = new Array(n).fill(1);
    
    // Initialize parent array
    for (let i = 0; i < n; i++) {
        parent[i] = i;
    }
    
    function find(x) {
        if (parent[x] !== x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    
    function union(x, y) {
        const px = find(x);
        const py = find(y);
        if (px !== py) {
            if (size[px] < size[py]) {
                [px, py] = [py, px];
            }
            parent[py] = px;
            size[px] += size[py];
        }
    }
    
    // Build the graph
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            if (graph[i][j]) {
                union(i, j);
            }
        }
    }
    
    // Count infected nodes in each component
    const infected = new Array(n).fill(0);
    for (const node of initial) {
        infected[find(node)]++;
    }
    
    // Find the best node to remove
    let bestNode = initial[0];
    let bestSize = 0;
    
    for (const node of initial) {
        const root = find(node);
        if (infected[root] === 1 && size[root] > bestSize) {
            bestSize = size[root];
            bestNode = node;
        }
    }
    
    return bestNode;
};</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(n^2)</h4>
                    <p class="text-gray-700">We need to process the adjacency matrix and perform union-find operations.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(n)</h4>
                    <p class="text-gray-700">We use arrays to store parent and size information for union-find.</p>
                </div>
            </div>

            <!-- C# Solution -->
            <div id="csharp" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">C# Solution</h3>
                <pre class="language-csharp"><code>public class Solution {
    private int[] parent;
    private int[] size;
    
    public int MinMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.Length;
        parent = new int[n];
        size = new int[n];
        
        // Initialize parent and size arrays
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
        
        // Build the graph
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (graph[i][j] == 1) {
                    Union(i, j);
                }
            }
        }
        
        // Count infected nodes in each component
        int[] infected = new int[n];
        foreach (int node in initial) {
            infected[Find(node)]++;
        }
        
        // Find the best node to remove
        int bestNode = initial[0];
        int bestSize = 0;
        
        foreach (int node in initial) {
            int root = Find(node);
            if (infected[root] == 1 && size[root] > bestSize) {
                bestSize = size[root];
                bestNode = node;
            }
        }
        
        return bestNode;
    }
    
    private int Find(int x) {
        if (parent[x] != x) {
            parent[x] = Find(parent[x]);
        }
        return parent[x];
    }
    
    private void Union(int x, int y) {
        int px = Find(x);
        int py = Find(y);
        if (px != py) {
            if (size[px] < size[py]) {
                int temp = px;
                px = py;
                py = temp;
            }
            parent[py] = px;
            size[px] += size[py];
        }
    }
}</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(n^2)</h4>
                    <p class="text-gray-700">We need to process the adjacency matrix and perform union-find operations.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(n)</h4>
                    <p class="text-gray-700">We use arrays to store parent and size information for union-find.</p>
                </div>
            </div>
        </div>
    </main>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-csharp.min.js"></script>
</body>
</html>