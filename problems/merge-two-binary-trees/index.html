<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merge Two Binary Trees - LeetCodee Solution</title>
    <meta name="description" content="Learn how to solve the Merge Two Binary Trees problem on LeetCodee.  Find detailed explanations, Python, Java, C++, JavaScript, and C# solutions with time and space complexity analysis.">
    <meta name="keywords" content="leetcode, merge two binary trees, binary tree, algorithm, data structure, python, java, javascript, c++, c#, solution, tutorial, coding, interview">
    <link rel="canonical" href="https://leetcodee.com/problems/merge-two-binary-trees/">
    <meta property="og:title" content="Merge Two Binary Trees - LeetCodee Solution">
    <meta property="og:url" content="https://leetcodee.com/problems/merge-two-binary-trees/">
    <meta property="og:description" content="Learn how to solve the Merge Two Binary Trees problem on LeetCodee.  Find detailed explanations, Python, Java, C++, JavaScript, and C# solutions with time and space complexity analysis.">
    <meta property="og:type" content="article">
    <meta property="og:image" content="https://leetcodee.com/logo.png">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-F7SQYSXXMM"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-F7SQYSXXMM');
    </script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1068871795581451" crossorigin="anonymous"></script>
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Article",
      "headline": "Merge Two Binary Trees - LeetCodee Solution",
      "author": {
        "@type": "Person",
        "name": "LeetCodee"
      },
      "datePublished": "2024-10-27",
      "description": "Learn how to solve the Merge Two Binary Trees problem on LeetCodee.  Find detailed explanations, Python, Java, C++, JavaScript, and C# solutions with time and space complexity analysis.",
      "articleBody": "This article provides solutions and explanations for the Merge Two Binary Trees problem...",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://leetcodee.com/problems/merge-two-binary-trees/"
      }
    }
    </script>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body class="bg-gray-100">
    <header class="bg-gray-800 text-white p-4">
        <div class="container mx-auto">
            <a href="/" class="text-xl font-bold">LeetCodee</a>
        </div>
    </header>

    <main class="container mx-auto p-4">
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h1 class="text-3xl font-bold mb-4">617. Merge Two Binary Trees</h1>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Problem Description</h2>
                <p class="text-gray-700 mb-4">
                    You are given two binary trees <code class="bg-gray-100 px-1 rounded">root1</code> and <code class="bg-gray-100 px-1 rounded">root2</code>.
                </p>
                <p class="text-gray-700 mb-4">
                    Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.
                </p>
                <p class="text-gray-700 mb-4">
                    Return the merged tree.
                </p>
                <p class="text-gray-700">
                    <strong>Note:</strong> The merging process must start from the root nodes of both trees.
                </p>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Example 1:</h2>
                <pre class="bg-gray-100 p-4 rounded"><code>Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
Output: [3,4,5,5,4,null,7]</code></pre>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Example 2:</h2>
                <pre class="bg-gray-100 p-4 rounded"><code>Input: root1 = [1], root2 = [1,2]
Output: [2,2]</code></pre>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Constraints:</h2>
                <ul class="list-disc list-inside text-gray-700">
                    <li>The number of nodes in both trees is in the range <code class="bg-gray-100 px-1 rounded">[0, 2000]</code></li>
                    <li><code class="bg-gray-100 px-1 rounded">-10^4 <= Node.val <= 10^4</code></li>
                </ul>
            </div>
        </div>

        <!-- Solution Section -->
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h2 class="text-2xl font-bold mb-4">Solution</h2>
            
            <!-- Python Solution -->
            <div id="python" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">Python Solution</h3>
                <pre class="language-python"><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root1:
            return root2
        if not root2:
            return root1
            
        root1.val += root2.val
        root1.left = self.mergeTrees(root1.left, root2.left)
        root1.right = self.mergeTrees(root1.right, root2.right)
        
        return root1</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(min(n1, n2))</h4>
                    <p class="text-gray-700">Where n1 and n2 are the number of nodes in the trees.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(min(h1, h2))</h4>
                    <p class="text-gray-700">Where h1 and h2 are the heights of the trees (due to recursion stack).</p>
                </div>
            </div>

            <!-- Java Solution -->
            <div id="java" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">Java Solution</h3>
                <pre class="language-java"><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if (root1 == null) {
            return root2;
        }
        if (root2 == null) {
            return root1;
        }
        
        root1.val += root2.val;
        root1.left = mergeTrees(root1.left, root2.left);
        root1.right = mergeTrees(root1.right, root2.right);
        
        return root1;
    }
}</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(min(n1, n2))</h4>
                    <p class="text-gray-700">Where n1 and n2 are the number of nodes in the trees.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(min(h1, h2))</h4>
                    <p class="text-gray-700">Where h1 and h2 are the heights of the trees (due to recursion stack).</p>
                </div>
            </div>

            <!-- C++ Solution -->
            <div id="cpp" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">C++ Solution</h3>
                <pre class="language-cpp"><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if (!root1) {
            return root2;
        }
        if (!root2) {
            return root1;
        }
        
        root1->val += root2->val;
        root1->left = mergeTrees(root1->left, root2->left);
        root1->right = mergeTrees(root1->right, root2->right);
        
        return root1;
    }
};</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(min(n1, n2))</h4>
                    <p class="text-gray-700">Where n1 and n2 are the number of nodes in the trees.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(min(h1, h2))</h4>
                    <p class="text-gray-700">Where h1 and h2 are the heights of the trees (due to recursion stack).</p>
                </div>
            </div>

            <!-- JavaScript Solution -->
            <div id="javascript" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">JavaScript Solution</h3>
                <pre class="language-javascript"><code>/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root1
 * @param {TreeNode} root2
 * @return {TreeNode}
 */
var mergeTrees = function(root1, root2) {
    if (!root1) {
        return root2;
    }
    if (!root2) {
        return root1;
    }
    
    root1.val += root2.val;
    root1.left = mergeTrees(root1.left, root2.left);
    root1.right = mergeTrees(root1.right, root2.right);
    
    return root1;
};</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(min(n1, n2))</h4>
                    <p class="text-gray-700">Where n1 and n2 are the number of nodes in the trees.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(min(h1, h2))</h4>
                    <p class="text-gray-700">Where h1 and h2 are the heights of the trees (due to recursion stack).</p>
                </div>
            </div>

            <!-- C# Solution -->
            <div id="csharp" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">C# Solution</h3>
                <pre class="language-csharp"><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
public class Solution {
    public TreeNode MergeTrees(TreeNode root1, TreeNode root2) {
        if (root1 == null) {
            return root2;
        }
        if (root2 == null) {
            return root1;
        }
        
        root1.val += root2.val;
        root1.left = MergeTrees(root1.left, root2.left);
        root1.right = MergeTrees(root1.right, root2.right);
        
        return root1;
    }
}</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(min(n1, n2))</h4>
                    <p class="text-gray-700">Where n1 and n2 are the number of nodes in the trees.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(min(h1, h2))</h4>
                    <p class="text-gray-700">Where h1 and h2 are the heights of the trees (due to recursion stack).</p>
                </div>
            </div>
            <ins class="adsbygoogle"
                 style="display:block"
                 data-ad-client="ca-pub-1068871795581451"
                 data-ad-slot="1234567890"
                 data-ad-format="auto"
                 data-full-width-responsive="true"></ins>
        </div>

        <!-- Approach Explanation -->
        <div class="bg-white rounded-lg shadow-lg p-6">
            <h2 class="text-2xl font-bold mb-4">Approach Explanation</h2>
            
            <div class="space-y-4">
                <p class="text-gray-700">
                    The solution uses a recursive approach to merge two binary trees:
                </p>
                
                <ol class="list-decimal list-inside text-gray-700 ml-4">
                    <li>Key Insights:
                        <ul class="list-disc list-inside ml-8">
                            <li>Recursive tree traversal</li>
                            <li>Node value summation</li>
                            <li>Null node handling</li>
                            <li>Tree modification</li>
                        </ul>
                    </li>
                    <li>Algorithm Steps:
                        <ul class="list-disc list-inside ml-8">
                            <li>Handle base cases (null nodes)</li>
                            <li>Sum node values</li>
                            <li>Recursively merge left subtrees</li>
                            <li>Recursively merge right subtrees</li>
                        </ul>
                    </li>
                </ol>

                <p class="text-gray-700 mt-4">
                    Implementation Details:
                    <ul class="list-disc list-inside ml-4">
                        <li>Recursive function</li>
                        <li>Node value addition</li>
                        <li>Tree modification</li>
                        <li>Null checks</li>
                    </ul>
                </p>

                <p class="text-gray-700 mt-4">
                    Optimization Insights:
                    <ul class="list-disc list-inside ml-4">
                        <li>In-place modification</li>
                        <li>Early termination</li>
                        <li>Reuse existing nodes</li>
                        <li>Minimal space usage</li>
                    </ul>
                </p>

                <p class="text-gray-700 mt-4">
                    Edge Cases:
                    <ul class="list-disc list-inside ml-4">
                        <li>Empty trees</li>
                        <li>Single node trees</li>
                        <li>Unbalanced trees</li>
                        <li>Different tree heights</li>
                    </ul>
                </p>
            </div>
        </div>
    </main>

    <footer class="bg-gray-800 text-white p-4 mt-8">
        <div class="container mx-auto text-center">
            <p>Â© 2024 LeetCodee. All rights reserved.</p>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>